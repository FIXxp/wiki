---
description: Подпись лаунчера
---

# Подпись лаунчера

## Где взять сертификат?

- Сгенерировать самому себе самоподписанный сертификат(например с помощью GenerateCertificateModule или по инструкциям ниже)  
- Попросить сертификат у того, кто уже настроил грамотно свой СА и может подписывать другие сертификаты  
- Создать CSR, и передать его человеку, который его подпишет  
- Можно отдавать каждый билд лаунчера человеку, имеющему сертификат, но не являющийся СА, на подпись.
- Можно купить сертификат для подписи лаунчера у официальных СА (очень дорого)  

## Подпись jar

### Требования

- Версия 5.1.0+
- Сертификат

### Конфигурация

<CodeGroup>
  <CodeGroupItem title="PKCS12" active>

```json
"sign": {
    "enabled": false,
    "keyStore": "MyKeyStore.p12",
    "keyStoreType": "PKCS12",
    "keyStorePass": "mypass",
    "keyAlias": "myname",
    "keyPass": "mypass",
    "metaInfKeyName": "SIGNUMO.RSA",
    "metaInfSfName": "SIGNUMO.SF",
    "signAlgo": "SHA256WITHRSA"
  }
```

  </CodeGroupItem>JKS
  <CodeGroupItem title="JKS" active>

```json
"sign": {
    "enabled": false,
    "keyStore": "MyKeyStore.p12",
    "keyStoreType": "JKS",
    "keyStorePass": "mypass",
    "keyAlias": "myname",
    "keyPass": "mypass",
    "metaInfKeyName": "SIGNUMO.RSA",
    "metaInfSfName": "SIGNUMO.SF",
    "signAlgo": "SHA256WITHRSA"
  }
```

  </CodeGroupItem>
</CodeGroup>

#### Описания конфигурации

`enabled` - Включить подпись своим сертификатом  
`keyStore` - Путь к хранилищу ключей  
`keyStoreType` - Тип хранилища  
`keyStorePass` - Пароль от хранилища  
`keyAlias` - Key Alias  
`keyPass` - Пароль от ключа, может не совпадать с storepass  
`signAlgo` - Алгоритм подписи  

## Подпись exe

[Модуль OpenSSLSignCode](https://github.com/GravitLauncher/LauncherModules/tree/master/OpenSSLSignCode_module) позволяет подписывать **Launcher.exe** своим сертификатом используя утилиту osslsigncode.

### Установка модуля

1. Скопировать модуль **OpenSSLSignCode_module.jar** в папку **/LaunchServer/modules/**.
2. Обязательно создать самоподписанный сертификат или купить его.
    - В конфигурации **LaunchServer.json** `"sign": { "enabled": true }`.
3. Установленная программа **osslsigncode**.
<CodeGroup>
  <CodeGroupItem title="Debian-подобные системы" active>

```bash
sudo apt install osslsigncode
```

  </CodeGroupItem>

  <CodeGroupItem title="CentOS">

```sh
cd /etc/yum.repos.d/
wget https://download.opensuse.org/repositories/home:danimo/CentOS_7/home:danimo.repo
yum install osslsigncode calc
```

  </CodeGroupItem>
</CodeGroup>

1. Выполнить **build** в консоли *LaunchServer*, если всё сделали правильно, **exe** будет подписан сертификатом.

### Конфигурация

Путь: `/LaunchServer/config/OSSLSignCode/Config.json`

```json
{
  "timestampServer": "http://timestamp.globalsign.com/scripts/timstamp.dll",
  "osslsigncodePath": "osslsigncode",
  "customArgs": [],
  "checkSignSize": true,
  "checkCorrectSign": true,
  "checkCorrectJar": true
}
```

### Команды

Подписывает exe, созданный с помощью launch4j вручную

```
osslsignexe [path to input exe] [path to output exe]
```

### Замечания

- Иногда вы можете получать ошибку о несоответствии размера подписи. Это происходит из за *timestamp server*, так как
  нельзя заранее угадать совпадет ли размер подписи в первом вызове и во втором. Если это вас беспокоит вы можете
  отключить использование `timestampServer` путем удаление этой строчки из конфигурации.


## Получение своего сертификата

### Создание самоподписаного CodeSign сертификата

Вы не хотите ни от кого зависить и полностью владеть всей цепочкой сертификатов? Тогда вам сюда. В этом разделе мы создадим базовую цепочку сертификатов с одним СА и одним конечным сертификатом. Этого хватит что бы подписать JAR и EXE лаунчера и пройти проверки

Создавать мы будем с помощью утилиты [XCA](https://github.com/chris2511/xca/releases). Выбирайте последний релиз, качаете, устанавливаете

1. Создайте базу данных. При создании базы данных обязательно задайте пароль и сохраните/запишите его в безопасное место. Старайтесь придерживаться правил безопастности - это доступ к всем вашим сертификатам.  
2. Перейдите во вкладку "Сертификаты" и нажмите кнопку "Новый сертификат"
3. Во вкладке "Субьект" укажите поле commonName - например "SuperCraft Root CA". Рекомендуется ввести имя, заканчивающиеся на "Root CA" - так будет проще и вам, и всем остальным кто будет смотреть ваш сертификат
4. В той же вкладке "Субъект" внизу нажмите на кнопку "Сгенерировать новый ключ". Тип ключа - RSA, длинна ключа - 4096 бит. Нажмите "Создать"
5. В вкладке "Расширения" выберите "тип" - "Центр Сертификации", в графе "Выбор периода" укажите от 1 до 10 лет и нажмите кнопку "Применить", после чего дата окончания должна сдвинуться на указанное вами число лет
6. В вкладке "Область приминения ключа" в первой колонке укажите "Digitial Signature" и "Certificate Sign", во второй "Code Signing", больше ничего в этой вкладке менять не нужно
7. В вкладке "Netscape" если что либо написано в поле "Netscape Comment" - уберите
8. После чего если вы уверены в веденных параметрах можно нажать "ОК". Вы создали корневой сертификат!
9. Экспортируем корневой сертификат. Для этого выберите свежесозданный сертификат и нажмите кнопку "Экспорт". Формат экспорта - "PEM (.crt)", файл куда экспортировать выберите сами на свое усмотрение. Нажимаете кнопку "ОК"
10. Далее вам нужно создать конечный сертификат, которым вы будете подписывать лаунчер(JAR и/или EXE). Нажимаете "Новый сертификат"
11. В Вкладке "Первоисточник" должен быть выбран "Использовать этот сертификат для подписи" где должен быть указан ваш Root CA, созданный на предыдущем этапе
12. В вкладке "Субъект" укажите поле commonName - например "SuperCraft Code Sign". Рекомендуется ввести имя, заканчивающиеся на "Code Sign" - так будет проще и вам, и всем остальным кто будет смотреть ваш сертификат
13. В той же вкладке "Субъект" внизу нажмите на кнопку "Сгенерировать новый ключ". Тип ключа - RSA, длинна ключа - 2048 бит. Нажмите "Создать"
14. В вкладке "Расширения" выберите "тип" - "Конечный субъект", в графе "Выбор периода" укажите от 1 до 10 лет и нажмите кнопку "Применить", после чего дата окончания должна сдвинуться на указанное вами число лет. Обратите внимание - срок действия конечного сертификата не может быть больше срока действия вашего Root CA. Меньше можно, больше - нет
15. Все прочие настройки аналогичны. В вкладке "Область приминения ключа" в первой колонке укажите "Digitial Signature"(и не указывайте Certificate Sign), во второй "Code Signing", больше ничего в этой вкладке менять не нужно. В вкладке "Netscape" если что либо написано в поле "Netscape Comment" - уберите. После чего если вы уверены в веденных параметрах можно нажать "ОК"
16. Вы создали конечный сертификат! Осталось этот сертификат экспортировать. Выберите ваш "Code Sign" сертификат и нажмите кнопку "Экспорт". Формат экспорта - "Цепочка PKCS12", месторасположение выбирайте сами. Введите пароль, которым будет зашифрован ваш .p12 контейнер. Пароль не должен совпадать с паролем от вашей базы данных, это небезопасно. Именно этот пароль вы будете указывать в конфигурации при подписи
Всё! Уже можно пользоваться. Файл **_Root_CA.crt(ваш корневой сертификат) скопируйте в папку truststore лаунчсервера. При желании установите его в ваш ПК как доверенный центр сертификации. А дальше можете настраивать подпись JAR/EXE уже своим сертификатом

### Создание самоподписаного CA

Хотите почувствовать себя настоящим экспертом? Что бы всё выглядело максимально правдоподобно и серьезно? Хотите не только подписывать JAR/EXE, а вообще что угодно где используются сертификаты? Тогда вам сюда. Вам понадобится всё тот же [XCA](https://github.com/chris2511/xca/releases)

1. Начнем с самого важного - ключа вашего центрального Root CA сертификата. Создайте базу данных XCA прямо на флешке и сгенерируйте ключ RSA с длинной не менее 4096 бит. После чего приступайте к созданию Root CA сертификата. В разделе "Субъект" укажите все основные параметры, исключая emailAddress, что бы всё выглядело серьезно. На дополнительные параметры можно забить в этой вкладке, они не нужны. В разделе "Расширения" укажите тип - "Центр сертификации", срок действия минимум 5 лет. "Область приминения ключа" - "Certificate Sign" и "CRL Sign", всё остальное без изменений. В разделе "Netscape" всё можно оставить пустым
2. Дальше создайте в той же базе данных "дополнительный" CA с настройками как у Root CA, а в имени либо номер, либо год. Единственное отличие в "Расширения" в поле "X.509v3 CRL" укажите URL на ваш сайт, где будет находится центральный CRL(например https://ca.example.com/root.crl). Этот СА вы будете использовать вместо центрального Root CA для создания других сертификатов. После чего экспортируйте ключ и сам сертификат дополнительного СА а так же только сертификат Root CA. Ключ Root CA не должен покидать пределы флешки. Дальше я для удобства будут называть этот CA - "2020 CA"
3. Создайте CRL root.crl используя ваш Root CA(ПКМ->ЦС->Сгенерировать CRL) и экспортируйте его. Потом вы его зальете себе на сайт по тому URL что указали выше, когда генерировали 2020 CA
4. Сохраните эту базу данных на еще одну флешку, CD диск, что угодно что будет не подключено к вашему ПК физически(а значит и ключ Root CA будет в безопастности) и что внезапно сразу не сломается
5. Создайте новю базу данных уже в другом месте(к примеру на вашем жестком диске) куда импортируйте сертификат Root CA, сертификат 2020 CA и ключ 2020 CA. Дальше вы будете работать только с этой базой.
6. Создайте CA, который будет служить определенной цели, например "Code Sign RSA CA", указав в качестве CRL что то вроде https://ca.example.com/2020.crl . Все CA, созданные с помощью 2020 CA будут использовать этот CRL URL. Есстественно заполняя все необходимые поля
7. Сгенерируйте CRL для 2020 CA(https://ca.example.com/2020.crl) и всех специализированных CA(https://ca.example.com/2020/codesign.crl). Потом вы зальете их на сайт по тому URL что указали
8. И вот теперь можете создавать конечные сертификаты. Бывает нужно указать какой то особый OID, которого нет в GUI. Тогда вы идете в Дополнительно->Редактировать и там вы можете указать любые параметры, которые можно указать в конфигурации OpenSSL. К примеру добавить кастомные extendedKeyUsage